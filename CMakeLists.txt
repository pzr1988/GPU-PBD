CMAKE_MINIMUM_REQUIRED(VERSION 3.5)
PROJECT(GPUPBD VERSION 1.0.0 LANGUAGES CXX CUDA)

#COMPILE SETTINGS
SET(CMAKE_CXX_STANDARD 17)
SET(CMAKE_CXX_STANDARD_REQUIRED True)
SET(CMAKE_BUILD_TYPE Release CACHE STRING "Compiler optimization level")
SET_PROPERTY(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS Debug Release)
SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${PROJECT_SOURCE_DIR}/cmake/ ${PROJECT_SOURCE_DIR}/extern/eigen/cmake)
IF(CMAKE_BUILD_TYPE STREQUAL "Debug")
  MESSAGE(STATUS "Build type: Debug")
  IF(MSVC)
    SET(CMAKE_CXX_FLAGS "/bigobj -Wall ${CMAKE_CXX_FLAGS}")
  ELSE(MSVC)
    SET(CMAKE_CXX_FLAGS "-O0 -Wall -fPIC -Wno-parentheses -Wno-unused-function -Wno-unused-local-typedefs ${CMAKE_CXX_FLAGS}")
  ENDIF(MSVC)
ELSE()
  MESSAGE(STATUS "Build type: Release")
  IF(MSVC)
    SET(CMAKE_CXX_FLAGS "/bigobj -Wall ${CMAKE_CXX_FLAGS}")
  ELSE(MSVC)
    SET(CMAKE_CXX_FLAGS "-O3 -Wall -fPIC -Wno-parentheses -Wno-unused-function -Wno-unused-local-typedefs ${CMAKE_CXX_FLAGS}")
  ENDIF(MSVC)
ENDIF()
SET(CMAKE_CONFIGURATION_TYPES ${CMAKE_BUILD_TYPE})

#LIBRARY SETTINGS
INCLUDE("${PROJECT_SOURCE_DIR}/cmake/LoadLibs.cmake")

#THIRD PARTY HEADERS
INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR})
MACRO(SEARCH_SOURCE NAME DIRPRJ)
  FILE(GLOB_RECURSE header${NAME} ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.h ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.hpp ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.hh)
  FILE(GLOB_RECURSE source${NAME} ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.cpp ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.cc ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.c)
  FILE(GLOB_RECURSE cuda_source${NAME} ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.cu ${PROJECT_SOURCE_DIR}/${DIRPRJ}/*.cuh)
ENDMACRO(SEARCH_SOURCE)
SEARCH_SOURCE(PBD PBD)
SEARCH_SOURCE(LBVH LBVH)

# #BUILD LIBRARY (GPU part)
# IF(${GPU_SUPPORTED})
# SET(CUDA_SEPARABLE_COMPILATION ON)
# CUDA_ADD_LIBRARY(PBDGPU STATIC ${cuda_sourcePBD} ${cuda_sourceLBVH} OPTIONS --expt-relaxed-constexpr --std=c++17)
# SET_TARGET_PROPERTIES(PBDGPU PROPERTIES CUDA_ARCHITECTURES "86")
# ENDIF()
# #BUILD LIBRARY (CPU part)
# ADD_LIBRARY(PBD SHARED ${sourcePBD} ${headerPBD})
# TARGET_COMPILE_OPTIONS(PBD PUBLIC "-std=c++17")
# TARGET_LINK_LIBRARIES(PBD PBDGPU stdc++fs ${ALL_LIBRARIES})
# LIST(APPEND ALL_STATIC_LIBRARIES PBD PBDGPU)

#EXE
MACRO(ADD_EXE NAME)
message(STATUS "Your cuda_sourcePBD is: ${cuda_sourcePBD}")
ADD_EXECUTABLE(${NAME} Main/${NAME}.cu ${cuda_sourcePBD} ${cuda_sourceLBVH})
SET_TARGET_PROPERTIES(${NAME} PROPERTIES CUDA_ARCHITECTURES "86")
TARGET_SOURCES(${NAME} PRIVATE ${sourcePBD} ${headerPBD})

# 设置 CUDA 编译器标志，包括 --extended-lambda
set_target_properties(${NAME} PROPERTIES
                      CUDA_SEPARABLE_COMPILATION ON)
target_compile_options(${NAME} PRIVATE $<$<COMPILE_LANGUAGE:CUDA>:
                       --extended-lambda
                       >)

# 链接 CUDA 库（如果需要）
find_package(CUDA REQUIRED)
target_link_libraries(${NAME} ${CUDA_LIBRARIES})

# 链接 stdc++fs 库
target_link_libraries(${NAME} stdc++fs)

# 链接 MPFR 库
find_library(MPFR_LIBRARY mpfr)
if(MPFR_LIBRARY)
    target_link_libraries(${NAME} ${MPFR_LIBRARY})
else()
    message(FATAL_ERROR "MPFR library not found")
endif()
TARGET_LINK_LIBRARIES(${NAME} stdc++fs ${ALL_STATIC_LIBRARIES})
ENDMACRO(ADD_EXE)

#DEBUG
ADD_EXE(mainDebugCollision)
